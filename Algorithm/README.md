# <center>算法导论实验报告<center>


## [Problem1](DFS.py)

#### 删去图中的某些边生成一个无环图

* 在进行DFS过程中,若当前搜索点$u$的邻接点$v$为灰色,则边$(u,v)$为一条后向边且在图中$u,v$之间存在环路.

  证明:在搜索点$u$时,点$v$为灰色,可以得到$d[v]<d[u]<f[u]<f[v]$,因此点$u$时点$v$的后代.

* 方法:在DFS记录图中的后向边,并在图中删除这些后向边即可得到一个无环图.

## [Problem2](CutofGraph.py)

#### 寻找连通无向图的割点

* 图中某一点$u$为割点的充分条件为:
  * $u$为一棵DFS树的根节点,且$u$具有两个及两个以上的子树
  * $u$并非根节点,$u$的所有子树中的节点没有指向$u$的祖先的后向边.也就是删除$u$之后,根节点无法到达$u$的子树中的节点.

* 数据结构:在DFS的基础上,用数组$d$记录图中节点第一次被搜索到的时间,数组$low$记录节点及其子树中的节点能够通过非父子边的后向边追溯到的最早的祖先节点.即

$$
low[u] = \begin{cases}
min\{low[u],min[v]\} &\text{$(u,v)$是树边}\\
min\{low[u],d[v] \}  &\text{$(u,v)$为后向边且$v$不是$u$的父节点}
\end{cases}
$$

* 方法:
  * 对于第一个条件,只需在DFS过程中判断根节点是否有两个或两个以上的子代即可,
  * 对于第二个条件,当$u$并非根节点,$u$和$v$之间有一树边,且$low[v]\ge d[u]$,则可判断$u$为一割点.

## [Problem3](MST.py)

#### 用局部替换的方法求解最小生成树

* 局部替换法:

  ```
  从T=Φ开始
  for(图中的每条边e)
  	if 加入e不构成环,则T=T+e
      else e'是环上权重最大的边,T=T+e-e'
  ```

* 数据结构:

  * 并查集(DisjointSet):在并查集中,每个节点的$id$表示这个节点所属的树,值为树的根节点
    * find操作:返回某个节点的$id$,即该节点所属的树
    * union操作:将两个节点所属的树合并为一棵树

* 方法:

  * 初始条件下,每个节点的$id$为其本身,即所有节点各自形成一棵树

  * 遍历图的所有边,对边$e=(u,v)$,找到$u,v$各自所属的树,记作$parentu,parentv$.

    * 若$parentu!=parentv$,即$u,v$不在同一棵树中,故将边$e$加入$T$中不会生成环,然后将$u,v$所属的两棵树合并

    * 若$parentu==parentv$,即$u,v$在同一棵树中,此时加入边$e$产生环,因此利用BFS搜索当前未加入$e$时的$T$,利用$\pi$可以找到从$u$到$v$的一条路径,并由此找到这条路径上权重最大的边$e'$.

      * 若$w(e)\le w(e')$,则$T=T+e-e'$
      * 否则,继续遍历剩下的边

      

## [Problem4](NegativeCircle.py)

#### 寻找加权有向图中的一个负圈

* 数据结构:并查集

* 方法: 与Problem3类似,通过遍历图的所有边,找到可以生成圈的边,然后判断生成的圈是不是负圈.

* 区别: Problem3中加入边$e=(u,v)$可生成圈,此时$u,v$在$T$中,即$u,v$之间仅有一条边,利用BFS遍历一次得到的$\pi$即可得到这条边.在本问题中,$v,u$之间可能存在多条路径,因此需要找到加入$e$之前从$v$到$u$的所有路径.

  * 寻找$u,v$之间路径的方法(DFS+栈)

    ```python
    Mark=[]#若某个点u被访问过则Mark[u]=1
    stack=[]#栈
    stack.push(v)
    #当栈不为空时
    while stack!=empty:
        s = stack.pop()
        #遍历s的邻接链表
        while t in s.adjlist:
            #若t未被访问,则将t入栈且标记
            if Mark[t]==0:
                stack.push(t)
                Mark[t]=1
                #若t为u,则stack从栈底到栈顶的元素是一条从v到u的路径
                if t==u
                	#判断这条路径是否为负圈
                	if isNegativeCircle(stack):
                    	print('负圈:',stack)
                	#将u出栈,且将u设置为未被访问
                    stack.pop()
                    Mark[t]=0
                    #继续找s的下一个邻接点
                    continue
                flag=1#表示继续遍历栈顶元素的邻接链表,
                break
        if flag==1:#加入flag的目的是将22行与26行两个continue区分开
            continue
        else:	
     		#s遍历结束,出栈
    		stack.pop()       
                
    ```

    

## [Problem5](TSP.py)

#### 求一个有向加权完全图的最小TSP圈（顶点数$\le 5$）

* 方法:动态规划：

  * 定义函数$f(v_i,V)$表示从$v_i$,经过$V$中所有的顶点一次且仅一次,回到$v_0$所走过所有路径的最短长度.
    $$
    f(v_i,V) = min_{v_j\in V} \{  d_{ij}+f(v_j,V-v_j)\}
    $$

  * 另外,为了获得最短路径的表示,每一个$f(v_i,V)$ 函数除了返回最短路径的长度之外,还要返回一个链表,链表内容为从$v_i$到$v_0$的最短路径经过的顶点.

* 在本问题中，随机选择一个起始点，不妨设置$v_0=V[0]$,那么由$v_0$开始经过图中其他各点一次且仅一次回到$v_0$的最短路径长度即最小TSP圈的权重以及最短路为:
$$
l,Path = f(v_0,V-{v_0})
$$
伪代码

```python 
def f(u,s,V):
    '''
    u为当前顶点
    s为源点
    G为图
    '''
    if V==NULL:
        return w(u,s),node(u->s)
   	else:
		对V中所有v,求l,node = f(v,V-v)
        return w(u,v_min)+min(l),node(u->node)
```

* 缺点:递归函数产生了许多重复的子路权重和链表,当图的顶点数增大时很容易造成内存不足的问题,可以通过先计算$f$来解决.即计算出除$v_0$外的所有点,经过集合$V-v_0$的所有真子集中的所有点一次且仅一次回到$v_0$所走的最短路长度和最短路径.
